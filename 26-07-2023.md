# Table


- [Table](#table)
- [Let's get Hooked](#lets-get-hooked)
- [Cleaning code](#cleaning-code)
- [imp exp](#imp-exp)
- [export - 2 ways](#export---2-ways)
- [Folder Structure](#folder-structure)
- [rendering](#rendering)
- [Filter option](#filter-option)
- [Hooks](#hooks)
- [loading](#loading)
- [conditional rendering](#conditional-rendering)
- [component composition](#component-composition)
- [Tips](#tips)


# Let's get Hooked

- frameworks make developer experience easier
- anything that react does can be done by HTML, CSS, JS

# Cleaning code

- Seperate files for separate **components**
- `.js` or `.jsx` doesn't matter
- keep it simple and don't overthink

# imp exp

- Before `importing` file we need to `export` => first `give` and then `take`

## export - 2 ways

- `export default Component` - default export
- `import Component from "path"` for **default export**
- in the end of the path if we use or don't use extension it doesn't matter
- we can only have one default export in a file
- `named export` - when you need to export multiple things
- `just write export infront of the component or variable`
- for importing `import {name} from "path"`
- **You can use named export and default export together**
- we can import multiple components at once if they are from same path
- `import Component(from default) , {url} from "path" `

---

- links and hard coded data in separate folder => `utils` and in that `constants.jsx`
- it's good to use capital letters and snake case for urls
- while using links use `{}` because it is given as `variable in js`

## Folder Structure

- **src** folder contains source code
- **utils** contain all the hard coded data

### rendering

- we can render to root in two ways

1.  create root and then `root.render(<Component/>)`
2.  ```js
    ReactDOM.createRoot(document.getElementById("root")).render(
      <AppLayout></AppLayout>
    );
    ```

# Filter option

- in order to filter the top rated restaurants on clicking the button we need to change the restaurant list that is being passed to the card with the required logic
- it only updates the data but `ui doesn't update`

- **React is fast in dom manipulation**
- **UI and data are working in sync with each other**

# Hooks

- **HOOK** is a normal js function which has some pre-written logic
- **state variable** => (maintains state)

1. useState() - _for superpowerful variable_
2. useEffect()

- first we need to import ` named import` these hooks
- `const [listofrest,setList]= useState(default)`
- we cannot modify directly the listofrest
- we can use function as second parameter
- `const [listofrest,setList]= useStateof(default)`
- if we need to update the `listofrest` then we use `setList([])`

- ```js
       const [A,setA]=useState(a);
       <!-- this is same as -->
       const arr= useState(a);
       <!-- useState() returns an array of two elements first one is state variable and 2nd is used to set the state -->
       const [A,setA] = arr;
       const A= arr[0];
       const B = arr[1];
  ```

- **render- when ever state variable changes react rerender it's components**

# Reconciliation ( aka => react fiber(in react 16))

- The algorithm React uses to diff one tree with another to determine which parts need to be changed.=> **Reconciliation**
- react fiber => new way of finding the difference in dom and updating the DOM
- Virtual DOM (_React element=>actually its a js object_)- representation of actual DOM
- **Diff algorithm**- finds out the difference between the updated virtual dom and the previous virtual dom and then actually updates the dom on every render cycle
- Finding out the difference between two `html elements` is hard but that of two `objects is easier`

# why is react fast

- it is doing effiecient dom manipulation
- it has virtual dom (object)
- it has `diff algorithm` => finds out the difference between updated virtual dom and previous virtual dom and then actually updates the dom on every render cycle
- **Finding out the difference and then updating**

# Monolith architecture

- We have api, ui code, frontend, backend, authentication code, database connectivity code in our project
- if we have to make minor changes we have to compile and deploy the whole Bulky project

# Microservice architecture

- we have different service for different things
- All these combine to form a big app
- can have different tech stacks frontend `react`, backend in `java` and run on their `specific ports`
- `Seperate of concerns` and follows `single responsibility principle`
- Now these several services need to talk to each other => Make calls to different api's

# fetching data => API Call

- Two approaches

1. When to make an api call- (as soon as page loads)=> (we make api call) => (then we render data)
2. ( As soon as page loads) => (we quickly render UI) => (we make api call) => (we re-render new data)

- we use 2nd approach mostly
- gives better `UX` => renders whatever we can and see something and then slowly website loads after api call is made -` Rendering two doesn't matter in react`

# useEffect()

- named import
- syntax
- two arguments we pass into `useEffect`

  1. callback function
  2. dependency array

  ```js
  useEffect(() => {
    console.log("useEffect() was called");
  }, []);
  ```
- useEffect is called after component renders then the callback function is called
- if we need to do something after rendering we write in `useEffect()`
- if we console somthing else it prints first then `useEffect`

- so to make an api call using second method(load-render-api-rerender) we fetch the data using `useEffect()` just after rendering we make api call and  then re render

- `fetch` -> given by browser => fetches data from api 
- returns a promise .then() or catch() or use `async await`
- then convert to `json` data
- we get cors error => to bypass erros  we use cors blocker extension 




# loading
- it takes few seconds to fetch the data so in mean time we can show some `spinner like animation`
- but it is not a good practice
- **Shimmer UI** => resembles pages actual UI, so users will understand how quickly the web will load 
> if the api is taking time to load then use shimmer UI 

# conditional rendering
- rendering on the basis of condition
- Eg. rendering the shimmer UI if the `restaurants.length ==0`


# component composition
- component inside another component 
   


# Tips

- ensure u have images of same sizes like one is landscape and other is protrait doesn't fit

